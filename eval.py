"""
This files provides functions that evaluate the quality of bilingual translations 
"""

import numpy as np
from tqdm import tqdm 
from ot.gromov import gwggrad
from ot.gromov import sinkhorn

def eval_rot(l1, l2, l1_l2_dict, W):
    """ 
    Returns the P@10 precision in translation given by the matrix W
    
    Input : 
        l1 : embedding of the first language 
        l2 : embedding of the second language 
        l1_l2_dict : A ground truth bilingual dictionnary, can be generated by generateDictio.py 
        W : Matrix that map the space of l1-embeddings to the space of l2-embeddings. In most cases W, will be an isometry. 
        
        Output : percentage of success (P@10) (x is considered well translated if the embedding of its translation lies within the 10 nearest neighbors of W@x) 
        
    """
    success = 0
    for l1_word,l2_word in l1_l2_dict: 
        x = l1.word_vec(l1_word)
        translates = l2.similar_by_vector(W@x)
        for transword,_ in translates:
            if transword==l2_word:
                success+=1 
                break 
    return 100*success/len(l1_l2_dict)

def eval_perm(l1, l2, l1_l2_dict, P):
    """
    Returns the P@10 precision in translation given by a joint probability matrix P 
    
    Input : 
        l1 : embedding of the first language 
        l2 : embedding of the second language 
        l1_l2_dict : A ground truth bilingual dictionnary, can be generated by generateDictio.py 
        P : P[i, j] corresponds to the probability that the i-th word from l1 is the translation of the j-th word from l2 
        
    Output : 
        P@10 precision 
    """
        
        

    nb_tested_words = 0
    success = 0

    for l1_word, l2_word in l1_l2_dict:

        i = l1.vocab[l1_word].index
        
        if i >= P.shape[0]:
            break
        
        nb_tested_words += 1

        indices = np.argsort(P[i])[-10:]
        translates = [l2.index2word[j] for j in indices]

        for transword in translates:
            if transword == l2_word:
                success += 1
                break

    return 100 * success / nb_tested_words


def correct_words_perm(l1, l2, l1_l2_dict, P):
    """
    Returns correctly/incorrectly translated words from l2 by a joint probability matrix P 
    
    Input : 
        l1 : embedding of the first language 
        l2 : embedding of the second language 
        l1_l2_dict : A ground truth bilingual dictionnary, can be generated by generateDictio.py 
        P : P[i, j] corresponds to the probability that the i-th word from l1 is the translation of the j-th word from l2 
        
    Output : 
        correct : Set of correctly translated words 
        incorrect : Set of incorrectly translated words 
    """

    

    correct = set()
    incorrect = set()

    for l1_word, l2_word in l1_l2_dict:

        i = l1.vocab[l1_word].index
        
        if i >= P.shape[0]:
            break

        indices = np.argsort(P[i])[-10:]
        translates = [l2.index2word[j] for j in indices]

        for j, transword in enumerate(translates):
            if transword == l2_word:
                correct.add(l2_word)
                break
            elif j == len(translates) - 1:
                incorrect.add(l2_word)

    return correct, incorrect




def evalP10(l1, l2, l1_l2_dict, Pi):
    """
    Prints the P@10 precision in translation given by a joint probability matrix Pi and the rotation that best generalizes the matching induced by Pi. 
    
    Input : 
        l1 : embedding of the first language 
        l2 : embedding of the second language 
        l1_l2_dict : A ground truth bilingual dictionnary, can be generated by generateDictio.py 
        Pi : Pi[i, j] corresponds to the probability that the i-th word from l1 is the translation of the j-th word from l2 
    
    """
    
    
    print('P@10 Permutation : ',eval_perm(l1, l2, l1_l2_dict, Pi.T))
    u, _, vh = np.linalg.svd(l2.vectors[:N0].T @ Pi @ l1.vectors[:N0])
    Q = u@vh 
    print('P@10 Rotation : ',eval_rot(l1, l2, l1_l2_dict, Q))
    
    

def sinkhorn(A):
    """ Returns a bistochastic matrix obtanied by scaling A appropriately,
based on THE SINKHORN-KNOPP ALGORITHM: CONVERGENCE AND APPLICATIONS """
    N = A.shape[0]
    r = np.ones(N)
    c = np.ones(N)
    R = np.diag(r)@A@np.diag(c)
    Rr = R.sum(axis=1)
    Rc = R.sum(axis=0)
    while Rr.max()-Rr.min()>0.01 or Rc.max()-Rc.min()>0.01:
        c = 1/(A.T@r)
        r = 1/(A@c)
        R = np.diag(r)@A@np.diag(c)
        Rr = R.sum(axis=1)
        Rc = R.sum(axis=0)
    return R



    






